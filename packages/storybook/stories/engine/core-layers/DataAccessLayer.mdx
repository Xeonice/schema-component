import { Meta } from '@storybook/blocks'

<Meta title="Engine/Core Layers/Data Access Layer" />

# Data Access Layerï¼ˆæ•°æ®è®¿é—®å±‚ï¼‰

Data Access Layer æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„ IoC å±‚ï¼Œè´Ÿè´£ä¸å¤–éƒ¨æ•°æ®æºçš„é€šä¿¡ã€‚ç¬¬ä¸€ç‰ˆæ”¯æŒ HTTPï¼Œä½†æ¶æ„è®¾è®¡æ”¯æŒæœªæ¥æ‰©å±• GraphQLã€WebSocketã€gRPC ç­‰å¤šç§åè®®ã€‚

## æ ¸å¿ƒæ¦‚å¿µ

Data Access Layer ä½œä¸ºç‹¬ç«‹å±‚å…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š

- **åè®®æ— å…³** - é€šè¿‡ç»Ÿä¸€æ¥å£æŠ½è±¡ï¼Œæ”¯æŒå¤šç§æ•°æ®è®¿é—®åè®®
- **æ’æ‹”å¼è®¾è®¡** - å¯åœ¨è¿è¡Œæ—¶åˆ‡æ¢ä¸åŒçš„æ•°æ®è®¿é—®å®ç°
- **IoC ç®¡ç†** - é€šè¿‡ä¾èµ–æ³¨å…¥å®¹å™¨ç®¡ç†ç”Ÿå‘½å‘¨æœŸ
- **å¯æ‰©å±•æ€§** - è½»æ¾æ·»åŠ æ–°çš„åè®®æ”¯æŒ

## ç»Ÿä¸€æ•°æ®è®¿é—®æ¥å£

æ‰€æœ‰æ•°æ®è®¿é—®å®ç°éƒ½å¿…é¡»å®ç° `IDataAccessClient` æ¥å£ï¼š

```typescript
/**
 * æ•°æ®è®¿é—®å®¢æˆ·ç«¯ç»Ÿä¸€æ¥å£
 * æ‰€æœ‰æ•°æ®è®¿é—®å®ç°ï¼ˆHTTPã€GraphQLã€WebSocket ç­‰ï¼‰éƒ½éœ€è¦å®ç°æ­¤æ¥å£
 */
interface IDataAccessClient {
  // åŸºç¡€ CRUD
  getList(modelName: string, params: GetListParams): Promise<GetListResult>
  getOne(modelName: string, id: string | number): Promise<any>
  createOne(modelName: string, data: any): Promise<any>
  updateOne(modelName: string, id: string | number, data: any): Promise<any>
  deleteOne(modelName: string, id: string | number): Promise<boolean>

  // æ‰¹é‡æ“ä½œ
  getMany(modelName: string, ids: Array<string | number>): Promise<any[]>
  createMany(modelName: string, data: any[]): Promise<any[]>
  updateMany(modelName: string, ids: Array<string | number>, data: any): Promise<any[]>
  deleteMany(modelName: string, ids: Array<string | number>): Promise<boolean>

  // è‡ªå®šä¹‰æŸ¥è¯¢
  query(modelName: string, criteria: QueryCriteria): Promise<QueryResult>

  // è¿æ¥ç®¡ç†
  connect?(): Promise<void>
  disconnect?(): Promise<void>
  isConnected?(): boolean
}
```

### æŸ¥è¯¢æ¡ä»¶æ¥å£

```typescript
interface QueryCriteria {
  filter?: Record<string, any>
  sort?: Array<{ field: string; order: 'ASC' | 'DESC' }>
  pagination?: { page: number; pageSize: number }
  fields?: string[] // é€‰æ‹©è¿”å›çš„å­—æ®µ
  relations?: string[] // å…³è”æŸ¥è¯¢
}
```

### æŸ¥è¯¢ç»“æœæ¥å£

```typescript
interface QueryResult {
  data: any[]
  total: number
  hasMore?: boolean
  cursor?: string // ç”¨äºæ¸¸æ ‡åˆ†é¡µ
}
```

## HTTP Client å®ç°ï¼ˆPhase 1ï¼‰

ç¬¬ä¸€ç‰ˆå®ç°äº†å®Œæ•´çš„ HTTP å®¢æˆ·ç«¯æ”¯æŒã€‚

### HTTP é…ç½®æ¥å£

```typescript
interface HttpClientConfig {
  baseURL: string
  timeout?: number
  headers?: Record<string, string>
  interceptors?: {
    request?: Array<(config: RequestConfig) => RequestConfig | Promise<RequestConfig>>
    response?: Array<(response: ApiResponse) => ApiResponse | Promise<ApiResponse>>
    error?: Array<(error: any) => any>
  }
}

interface RequestConfig {
  url?: string
  method?: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH'
  params?: Record<string, any>
  data?: any
  headers?: Record<string, string>
  timeout?: number
}

interface ApiResponse<T = any> {
  data: T
  status: number
  statusText: string
  headers: Record<string, string>
}
```

### HTTP Data Access Client

```typescript
import { injectable, inject } from 'inversify'

@injectable()
class HttpDataAccessClient implements IDataAccessClient {
  private httpClient: any // axios, fetch wrapper ç­‰
  private urlMapper: IUrlMapper

  constructor(
    @inject(TYPES.HttpClient) httpClient: any,
    @inject(TYPES.UrlMapper) urlMapper: IUrlMapper,
    config: HttpClientConfig
  ) {
    this.httpClient = httpClient
    this.urlMapper = urlMapper
    this.setupInterceptors(config.interceptors)
  }

  async getList(modelName: string, params: GetListParams): Promise<GetListResult> {
    const url = this.urlMapper.mapGetList(modelName, params)
    const requestConfig = this.buildRequestConfig('GET', url, { params })

    const response = await this.httpClient.request(requestConfig)

    return this.transformListResponse(response.data)
  }

  async getOne(modelName: string, id: string | number): Promise<any> {
    const url = this.urlMapper.mapGetOne(modelName, id)
    const requestConfig = this.buildRequestConfig('GET', url)

    const response = await this.httpClient.request(requestConfig)

    return response.data
  }

  async createOne(modelName: string, data: any): Promise<any> {
    const url = this.urlMapper.mapCreateOne(modelName)
    const requestConfig = this.buildRequestConfig('POST', url, { data })

    const response = await this.httpClient.request(requestConfig)

    return response.data
  }

  async updateOne(modelName: string, id: string | number, data: any): Promise<any> {
    const url = this.urlMapper.mapUpdateOne(modelName, id)
    const requestConfig = this.buildRequestConfig('PUT', url, { data })

    const response = await this.httpClient.request(requestConfig)

    return response.data
  }

  async deleteOne(modelName: string, id: string | number): Promise<boolean> {
    const url = this.urlMapper.mapDeleteOne(modelName, id)
    const requestConfig = this.buildRequestConfig('DELETE', url)

    const response = await this.httpClient.request(requestConfig)

    return response.status >= 200 && response.status < 300
  }

  // æ‰¹é‡æ“ä½œ
  async getMany(modelName: string, ids: Array<string | number>): Promise<any[]> {
    const url = this.urlMapper.mapGetMany(modelName, ids)
    const requestConfig = this.buildRequestConfig('GET', url, {
      params: { ids: ids.join(',') }
    })

    const response = await this.httpClient.request(requestConfig)

    return response.data
  }

  async createMany(modelName: string, data: any[]): Promise<any[]> {
    const url = this.urlMapper.mapCreateOne(modelName)
    const requestConfig = this.buildRequestConfig('POST', url, {
      data: { items: data }
    })

    const response = await this.httpClient.request(requestConfig)

    return response.data
  }

  async query(modelName: string, criteria: QueryCriteria): Promise<QueryResult> {
    const url = this.urlMapper.mapQuery(modelName)
    const requestConfig = this.buildRequestConfig('POST', url, {
      data: criteria
    })

    const response = await this.httpClient.request(requestConfig)

    return response.data
  }

  // å·¥å…·æ–¹æ³•
  private buildRequestConfig(
    method: string,
    url: string,
    options?: { params?: any; data?: any }
  ): RequestConfig {
    return {
      method: method as any,
      url,
      params: options?.params,
      data: options?.data
    }
  }

  private transformListResponse(data: any): GetListResult {
    // æ”¯æŒä¸åŒçš„åç«¯ API å“åº”æ ¼å¼

    // æ ¼å¼ 1: ç›´æ¥è¿”å›æ•°ç»„
    if (Array.isArray(data)) {
      return {
        data,
        total: data.length
      }
    }

    // æ ¼å¼ 2: æ ‡å‡†æ ¼å¼ { data: [], total: number }
    if (data.data && Array.isArray(data.data)) {
      return {
        data: data.data,
        total: data.total || data.data.length,
        page: data.page,
        pageSize: data.pageSize
      }
    }

    // æ ¼å¼ 3: åˆ†é¡µæ ¼å¼ { items: [], count: number }
    if (data.items && Array.isArray(data.items)) {
      return {
        data: data.items,
        total: data.count || data.items.length
      }
    }

    // å…¶ä»–æ ¼å¼
    return data
  }

  private setupInterceptors(interceptors?: HttpClientConfig['interceptors']): void {
    if (!interceptors) return

    // è¯·æ±‚æ‹¦æˆªå™¨
    interceptors.request?.forEach(interceptor => {
      this.httpClient.interceptors.request.use(interceptor)
    })

    // å“åº”æ‹¦æˆªå™¨
    interceptors.response?.forEach(interceptor => {
      this.httpClient.interceptors.response.use(interceptor)
    })

    // é”™è¯¯æ‹¦æˆªå™¨
    interceptors.error?.forEach(interceptor => {
      this.httpClient.interceptors.response.use(undefined, interceptor)
    })
  }
}
```

## URL æ˜ å°„å™¨

URL æ˜ å°„å™¨è´Ÿè´£å°† Repository æ“ä½œæ˜ å°„ä¸ºå…·ä½“çš„ URLã€‚

### URL æ˜ å°„å™¨æ¥å£

```typescript
/**
 * URL æ˜ å°„å™¨æ¥å£
 * è´Ÿè´£å°† Repository æ“ä½œæ˜ å°„ä¸ºå…·ä½“çš„ URL
 */
interface IUrlMapper {
  mapGetList(modelName: string, params: GetListParams): string
  mapGetOne(modelName: string, id: string | number): string
  mapGetMany(modelName: string, ids: Array<string | number>): string
  mapCreateOne(modelName: string): string
  mapUpdateOne(modelName: string, id: string | number): string
  mapDeleteOne(modelName: string, id: string | number): string
  mapQuery(modelName: string): string
}
```

### REST URL æ˜ å°„å™¨å®ç°

```typescript
/**
 * REST é£æ ¼çš„ URL æ˜ å°„å™¨
 */
class RestUrlMapper implements IUrlMapper {
  constructor(
    private baseURL: string = '/api',
    private options?: {
      pluralize?: boolean // æ˜¯å¦å¤æ•°åŒ–æ¨¡å‹å
      customRoutes?: Record<string, string> // è‡ªå®šä¹‰è·¯ç”±æ˜ å°„
    }
  ) {}

  mapGetList(modelName: string, params: GetListParams): string {
    const resource = this.getResourceName(modelName)
    const queryString = this.buildQueryString(params)
    return `${this.baseURL}/${resource}${queryString}`
  }

  mapGetOne(modelName: string, id: string | number): string {
    const resource = this.getResourceName(modelName)
    return `${this.baseURL}/${resource}/${id}`
  }

  mapGetMany(modelName: string, ids: Array<string | number>): string {
    const resource = this.getResourceName(modelName)
    return `${this.baseURL}/${resource}`
  }

  mapCreateOne(modelName: string): string {
    const resource = this.getResourceName(modelName)
    return `${this.baseURL}/${resource}`
  }

  mapUpdateOne(modelName: string, id: string | number): string {
    const resource = this.getResourceName(modelName)
    return `${this.baseURL}/${resource}/${id}`
  }

  mapDeleteOne(modelName: string, id: string | number): string {
    const resource = this.getResourceName(modelName)
    return `${this.baseURL}/${resource}/${id}`
  }

  mapQuery(modelName: string): string {
    const resource = this.getResourceName(modelName)
    return `${this.baseURL}/${resource}/query`
  }

  private getResourceName(modelName: string): string {
    // æ£€æŸ¥è‡ªå®šä¹‰è·¯ç”±
    if (this.options?.customRoutes?.[modelName]) {
      return this.options.customRoutes[modelName]
    }

    // è½¬æ¢ä¸ºå°å†™
    let resource = modelName.toLowerCase()

    // å¯é€‰ï¼šå¤æ•°åŒ–
    if (this.options?.pluralize) {
      resource = this.pluralize(resource)
    }

    return resource
  }

  private pluralize(word: string): string {
    // ç®€å•çš„å¤æ•°åŒ–è§„åˆ™
    if (word.endsWith('y')) {
      return word.slice(0, -1) + 'ies'
    }
    if (word.endsWith('s')) {
      return word + 'es'
    }
    return word + 's'
  }

  private buildQueryString(params: GetListParams): string {
    const queryParams: string[] = []

    // åˆ†é¡µ
    if (params.pagination) {
      queryParams.push(`page=${params.pagination.page}`)
      queryParams.push(`pageSize=${params.pagination.pageSize}`)
    }

    // æ’åº
    if (params.sort && params.sort.length > 0) {
      const sortStr = params.sort
        .map(s => `${s.field}:${s.order}`)
        .join(',')
      queryParams.push(`sort=${sortStr}`)
    }

    // è¿‡æ»¤
    if (params.filter) {
      Object.entries(params.filter).forEach(([key, value]) => {
        queryParams.push(`${key}=${encodeURIComponent(value)}`)
      })
    }

    return queryParams.length > 0 ? `?${queryParams.join('&')}` : ''
  }
}
```

## ä½¿ç”¨ç¤ºä¾‹

### åŸºç¡€é…ç½®

```typescript
import axios from 'axios'
import {
  HttpDataAccessClient,
  RestUrlMapper,
  Repository
} from '@schema-component/engine'

// 1. åˆ›å»º HTTP å®¢æˆ·ç«¯
const httpClient = axios.create({
  baseURL: 'https://api.example.com',
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json'
  }
})

// 2. åˆ›å»º URL æ˜ å°„å™¨
const urlMapper = new RestUrlMapper('/api', {
  pluralize: true,
  customRoutes: {
    'User': 'users',
    'Post': 'posts'
  }
})

// 3. åˆ›å»º HTTP Data Access Client
const dataAccessClient = new HttpDataAccessClient(
  httpClient,
  urlMapper,
  {
    baseURL: 'https://api.example.com'
  }
)

// 4. åˆ›å»º Repository
const userRepository = new Repository('User', dataAccessClient)

// 5. ä½¿ç”¨ Repository
const users = await userRepository.getList({
  pagination: { page: 1, pageSize: 10 },
  sort: [{ field: 'createdAt', order: 'DESC' }],
  filter: { role: 'admin' }
})
```

### é…ç½®æ‹¦æˆªå™¨

```typescript
const dataAccessClient = new HttpDataAccessClient(
  httpClient,
  urlMapper,
  {
    baseURL: 'https://api.example.com',
    interceptors: {
      // è¯·æ±‚æ‹¦æˆªå™¨
      request: [
        async (config) => {
          // æ·»åŠ è®¤è¯ token
          const token = await getAuthToken()
          config.headers = {
            ...config.headers,
            Authorization: `Bearer ${token}`
          }
          return config
        },
        (config) => {
          // è¯·æ±‚æ—¥å¿—
          console.log('Request:', config.method, config.url)
          return config
        }
      ],

      // å“åº”æ‹¦æˆªå™¨
      response: [
        async (response) => {
          // å“åº”æ—¥å¿—
          console.log('Response:', response.status, response.statusText)
          return response
        }
      ],

      // é”™è¯¯æ‹¦æˆªå™¨
      error: [
        (error) => {
          // ç»Ÿä¸€é”™è¯¯å¤„ç†
          if (error.response?.status === 401) {
            // è·³è½¬åˆ°ç™»å½•é¡µ
            redirectToLogin()
          }

          if (error.response?.status === 500) {
            // æ˜¾ç¤ºé”™è¯¯æç¤º
            showErrorToast('Server error')
          }

          throw error
        }
      ]
    }
  }
)
```

### é€šè¿‡ DI å®¹å™¨é…ç½®

```typescript
import { Container, injectable, inject } from 'inversify'
import { TYPES } from '@schema-component/engine'

// å®šä¹‰æ ‡è¯†ç¬¦
const TYPES = {
  DataAccessClient: Symbol.for('DataAccessClient'),
  HttpClient: Symbol.for('HttpClient'),
  UrlMapper: Symbol.for('UrlMapper')
}

// é…ç½® DI å®¹å™¨
const container = new Container()

// ç»‘å®š HTTP å®¢æˆ·ç«¯
container.bind(TYPES.HttpClient).toConstantValue(axios.create({
  baseURL: 'https://api.example.com',
  timeout: 10000
}))

// ç»‘å®š URL æ˜ å°„å™¨
container.bind<IUrlMapper>(TYPES.UrlMapper).toConstantValue(
  new RestUrlMapper('/api', {
    pluralize: true,
    customRoutes: {
      'User': 'users',
      'Post': 'posts'
    }
  })
)

// ç»‘å®šæ•°æ®è®¿é—®å®¢æˆ·ç«¯
container.bind<IDataAccessClient>(TYPES.DataAccessClient).to(HttpDataAccessClient)

// ç»‘å®š Repositoryï¼ˆè‡ªåŠ¨æ³¨å…¥ Data Access Clientï¼‰
container.bind<IRepository>(TYPES.Repository).to(Repository)

// ä½¿ç”¨
const userRepository = container.get<IRepository>(TYPES.Repository)
const users = await userRepository.getList({ /* ... */ })
```

## æœªæ¥æ‰©å±•

### GraphQL Clientï¼ˆPhase 2ï¼‰

```typescript
class GraphQLDataAccessClient implements IDataAccessClient {
  constructor(
    private endpoint: string,
    private client: any // Apollo Client, urql ç­‰
  ) {}

  async getList(modelName: string, params: GetListParams): Promise<GetListResult> {
    const query = this.buildListQuery(modelName, params)
    const result = await this.client.query({ query })
    return result.data
  }

  async getOne(modelName: string, id: string | number): Promise<any> {
    const query = this.buildOneQuery(modelName, id)
    const result = await this.client.query({ query })
    return result.data
  }

  private buildListQuery(modelName: string, params: GetListParams): any {
    // æ„å»º GraphQL æŸ¥è¯¢
    return gql`
      query GetList($pagination: Pagination, $filter: Filter) {
        ${modelName.toLowerCase()}s(pagination: $pagination, filter: $filter) {
          data {
            id
            # æ ¹æ® Schema åŠ¨æ€ç”Ÿæˆå­—æ®µ
          }
          total
        }
      }
    `
  }

  // å®ç°å…¶ä»–æ–¹æ³•...
}
```

### WebSocket Clientï¼ˆPhase 3ï¼‰

```typescript
class WebSocketDataAccessClient implements IDataAccessClient {
  private ws: WebSocket
  private requestMap: Map<string, any> = new Map()

  constructor(private url: string) {
    this.ws = new WebSocket(url)
    this.setupListeners()
  }

  private setupListeners() {
    this.ws.addEventListener('message', (event) => {
      const response = JSON.parse(event.data)
      const pending = this.requestMap.get(response.id)

      if (pending) {
        pending.resolve(response.data)
        this.requestMap.delete(response.id)
      }
    })
  }

  async getOne(modelName: string, id: string | number): Promise<any> {
    return new Promise((resolve, reject) => {
      const requestId = this.generateRequestId()

      // ä¿å­˜ Promise resolver
      this.requestMap.set(requestId, { resolve, reject })

      // å‘é€è¯·æ±‚
      this.ws.send(JSON.stringify({
        id: requestId,
        type: 'getOne',
        modelName,
        params: { id }
      }))

      // è¶…æ—¶å¤„ç†
      setTimeout(() => {
        if (this.requestMap.has(requestId)) {
          this.requestMap.delete(requestId)
          reject(new Error('Request timeout'))
        }
      }, 30000)
    })
  }

  private generateRequestId(): string {
    return `${Date.now()}-${Math.random()}`
  }

  // å®ç°å…¶ä»–æ–¹æ³•...
}
```

## åˆ‡æ¢æ•°æ®è®¿é—®å®ç°

ç”±äºé‡‡ç”¨ IoC è®¾è®¡ï¼Œåˆ‡æ¢ä¸åŒçš„æ•°æ®è®¿é—®å®ç°éå¸¸ç®€å•ï¼š

```typescript
// ä½¿ç”¨ HTTPï¼ˆç¬¬ä¸€ç‰ˆï¼‰
container.bind<IDataAccessClient>(TYPES.DataAccessClient).to(HttpDataAccessClient)

// åˆ‡æ¢ä¸º GraphQL
container.bind<IDataAccessClient>(TYPES.DataAccessClient).to(GraphQLDataAccessClient)

// åˆ‡æ¢ä¸º WebSocket
container.bind<IDataAccessClient>(TYPES.DataAccessClient).to(WebSocketDataAccessClient)

// åŒæ—¶ä½¿ç”¨å¤šä¸ª Data Access Clientï¼ˆé€šè¿‡ named bindingï¼‰
container.bind<IDataAccessClient>(TYPES.DataAccessClient)
  .to(HttpDataAccessClient)
  .whenTargetNamed('http')

container.bind<IDataAccessClient>(TYPES.DataAccessClient)
  .to(GraphQLDataAccessClient)
  .whenTargetNamed('graphql')

// ä½¿ç”¨æ—¶æŒ‡å®š
const httpClient = container.getNamed<IDataAccessClient>(TYPES.DataAccessClient, 'http')
const graphqlClient = container.getNamed<IDataAccessClient>(TYPES.DataAccessClient, 'graphql')
```

## è‡ªå®šä¹‰ Data Access Client

å¦‚æœéœ€è¦æ”¯æŒè‡ªå®šä¹‰åè®®ï¼š

```typescript
class CustomDataAccessClient implements IDataAccessClient {
  async getList(modelName: string, params: GetListParams): Promise<GetListResult> {
    // è‡ªå®šä¹‰å®ç°
    // ä¾‹å¦‚ï¼šä»æœ¬åœ°æ•°æ®åº“è¯»å–
    // æˆ–è€…ï¼šè°ƒç”¨ RPC æœåŠ¡
    // æˆ–è€…ï¼šä»ç¼“å­˜è·å–
  }

  async getOne(modelName: string, id: string | number): Promise<any> {
    // è‡ªå®šä¹‰å®ç°
  }

  // ... å®ç°å…¶ä»–æ–¹æ³•
}

// æ³¨å†Œ
container.bind<IDataAccessClient>(TYPES.DataAccessClient).to(CustomDataAccessClient)
```

## æ¶æ„å…³ç³»å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Repository                    â”‚
â”‚  â€¢ ç¼“å­˜ç®¡ç†                                     â”‚
â”‚  â€¢ æ•°æ®è½¬æ¢                                     â”‚
â”‚  â€¢ ä¸šåŠ¡é€»è¾‘åè°ƒ                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚ (ä¾èµ–æ³¨å…¥)
                  â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            IDataAccessClient (æ¥å£)             â”‚
â”‚  â€¢ getList()                                    â”‚
â”‚  â€¢ getOne()                                     â”‚
â”‚  â€¢ createOne()                                  â”‚
â”‚  â€¢ updateOne()                                  â”‚
â”‚  â€¢ deleteOne()                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚ (å®ç°)
      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
      â–¼           â–¼           â–¼             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   HTTP   â”‚ â”‚ GraphQL  â”‚ â”‚WebSocket â”‚ â”‚  Custom  â”‚
â”‚  Client  â”‚ â”‚  Client  â”‚ â”‚  Client  â”‚ â”‚  Client  â”‚
â”‚    âœ…    â”‚ â”‚    ğŸ“‹    â”‚ â”‚    ğŸ“‹    â”‚ â”‚    ğŸ’¡    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚            â”‚            â”‚             â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚
                  â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  External Data  â”‚
        â”‚   (æ•°æ®æº)      â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## æ‰©å±•è·¯çº¿å›¾

### Phase 1 (ç¬¬ä¸€ç‰ˆ) - HTTP æ”¯æŒ âœ…

- âœ… `HttpDataAccessClient` å®ç°
- âœ… `RestUrlMapper` å®ç°
- âœ… HTTP æ‹¦æˆªå™¨æ”¯æŒ
- âœ… è¯·æ±‚/å“åº”è½¬æ¢

### Phase 2 (ç¬¬äºŒç‰ˆ) - GraphQL æ”¯æŒ ğŸ“‹

- ğŸ“‹ `GraphQLDataAccessClient` å®ç°
- ğŸ“‹ GraphQL æŸ¥è¯¢æ„å»ºå™¨
- ğŸ“‹ GraphQL ç¼“å­˜ç­–ç•¥
- ğŸ“‹ Subscription æ”¯æŒ

### Phase 3 (ç¬¬ä¸‰ç‰ˆ) - å®æ—¶é€šä¿¡æ”¯æŒ ğŸ“‹

- ğŸ“‹ `WebSocketDataAccessClient` å®ç°
- ğŸ“‹ å®æ—¶æ•°æ®åŒæ­¥
- ğŸ“‹ æ–­çº¿é‡è¿æœºåˆ¶
- ğŸ“‹ æ¶ˆæ¯é˜Ÿåˆ—ç®¡ç†

### Phase 4 (ç¬¬å››ç‰ˆ) - æ›´å¤šåè®® ğŸ“‹

- ğŸ“‹ `gRPC` æ”¯æŒ
- ğŸ“‹ `MQTT` æ”¯æŒ
- ğŸ“‹ è‡ªå®šä¹‰åè®®æ”¯æŒ

## æœ€ä½³å®è·µ

### 1. é”™è¯¯å¤„ç†

```typescript
class HttpDataAccessClient {
  async getOne(modelName: string, id: string | number): Promise<any> {
    try {
      const url = this.urlMapper.mapGetOne(modelName, id)
      const response = await this.httpClient.get(url)
      return response.data
    } catch (error) {
      // ç»Ÿä¸€é”™è¯¯å¤„ç†
      throw new DataAccessError(`Failed to fetch ${modelName}:${id}`, error)
    }
  }
}
```

### 2. é‡è¯•æœºåˆ¶

```typescript
class HttpDataAccessClient {
  private async requestWithRetry(
    config: RequestConfig,
    retries: number = 3
  ): Promise<any> {
    for (let i = 0; i < retries; i++) {
      try {
        return await this.httpClient.request(config)
      } catch (error) {
        if (i === retries - 1) throw error

        // æŒ‡æ•°é€€é¿
        await this.delay(Math.pow(2, i) * 1000)
      }
    }
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms))
  }
}
```

### 3. è¯·æ±‚å–æ¶ˆ

```typescript
class HttpDataAccessClient {
  private abortControllers: Map<string, AbortController> = new Map()

  async getList(modelName: string, params: GetListParams): Promise<GetListResult> {
    // å–æ¶ˆä¹‹å‰çš„è¯·æ±‚
    const key = `${modelName}:getList`
    this.abortControllers.get(key)?.abort()

    // åˆ›å»ºæ–°çš„ AbortController
    const controller = new AbortController()
    this.abortControllers.set(key, controller)

    try {
      const url = this.urlMapper.mapGetList(modelName, params)
      const response = await this.httpClient.get(url, {
        signal: controller.signal
      })

      return this.transformListResponse(response.data)
    } finally {
      this.abortControllers.delete(key)
    }
  }
}
```

## ä¸‹ä¸€æ­¥

äº†è§£å…¶ä»–æ ¸å¿ƒå±‚ï¼š

- [Model Layer](/docs/engine-core-layers-model-layer) - é¢†åŸŸæ¨¡å‹å®šä¹‰
- [Repository Layer](/docs/engine-core-layers-repository-layer) - æ•°æ®è®¿é—®åè°ƒ
- [State Layer](/docs/engine-core-layers-state-layer) - å“åº”å¼çŠ¶æ€ç®¡ç†

æˆ–æŸ¥çœ‹ï¼š

- [HTTP Module](/docs/engine-http-overview) - HTTP å®¢æˆ·ç«¯è¯¦ç»†æ–‡æ¡£
- [Architecture Overview](/docs/engine-architecture-overview) - æ•´ä½“æ¶æ„

---

**æœ€åæ›´æ–°**: 2025-10-31
